2  Цель работы: исследование типовых методов и алгоритмов разделения общего ресурса канала между абонентами, определение характеристик рассматриваемых алгоритмов в рамках базовой модели множественного доступа с использованием численных расчетов и имитационного моделирования.  Описание моделируемой системы Алгоритмы случайного доступа относятся к децентрализованным системам управления доступа к среде. При децентрализованном доступе устройства равноправны и по некоторому алгоритму они организовывают доступ к общему каналу.  Абонент передает сообщение по каналу сообщение готовое к передаче, если по каналу передаются сразу несколько сообщений от разных абонентов, то возникает конфликт, который разрешается по некоторому алгоритму.  Ряд допущений для рассматриваемой модели случайного множественного доступа:  1) Предполагается, что все сообщения у всех абонентов имеют одинаковую длину, время передачи одного сообщения принято за единицу времени. Все время передачи по каналу разбито на окна, длительность окна соответствует времени передачи одного сообщения. Абоненты точно знают моменты разделения и могут начать передачу только в начале окна.  2) В окне возможно 3 события:  • Событие «Конфликт». В окне одновременно передают два абонента или больше. Считается, что из-за наложения сигналов сообщения полностью искажаются и не могут быть приняты правильно.  • Событие «Успех». В окне передает один абонент, в этом случае считается, что абонент успешно передает сообщение.  • Событие «Пусто». В окне никто не передает.  3) Абоненты наблюдают выход канала в конце окна и достоверно определяют, какое из трех событий произошло.  4) В системе имеется 𝑀 абонентов. В среднем у всех абонентов в одну единицу времени возникает 𝜆 сообщений (интенсивность входного потока) (Пуассоновский входной поток с параметром 𝜆). Интенсивность входного потока у всех абонентов в системе одинакова и у каждого абонента она равна 𝜆/𝑀. 3  Алгоритмом случайного множественного доступа называется правило в соответствии, с которым каждый абонент, имеющий готовое к передаче сообщение, в начале каждого окна решает, передавать сообщение или нет.  Описание исследуемого алгоритма доступа к среде Рассматривается интервальный адаптивный алгоритм ALOHA. При интервальном варианте алгоритма абонент выбирают номер окна, в котором он будет передавать из интервала {1,2,…,𝑊𝑡} при этом параметр 𝑊𝑡 изменяется в соответствии с событиями в канале по следующему правилу: 𝑊𝑡+1= {min(2𝑀,2𝑊𝑡),"К"  𝑊𝑡,"У" max(1,𝑊𝑡2),"П"  где 𝑊𝑡 – размер интервала, в котором абонент выбирает окно для передачи в 𝑡-ом окне.  Блок-схема исследуемого алгоритма  Рисунок 1 - Блок-схема алгоритма   4   Расчеты значений Очевидно, что при  𝑀=1,𝑊0=1=𝑐𝑜𝑛𝑠𝑡 система будет работать так же, как синхронная система, а значит, теоретические и практические значения 𝑑(𝜆кр),𝑁(𝜆кр) и 𝜆вых(𝜆кр) будут совпадать.  Аналогично можно заметить, что при  𝑊𝑡=𝑊=𝑐𝑜𝑛𝑠𝑡 система будет работать так же, как интервальный АЛОХА, а, значит значения 𝑑(𝜆кр),𝑁(𝜆кр) и 𝜆вых(𝜆кр) будут совпадать. Можно привести расчет теоретического значения 𝜆кр для данного случая для сравнения со значениями, полученными путем моделирования.  Известно, что для вероятностного алгоритма АЛОХА средняя задержка: 𝑑0(𝑝)=12+1𝑝 Также для вероятностного алгоритма АЛОХА критическая интенсивность входного потока определяется как: 𝜆кр=𝑀𝑝(1−𝑝)𝑀−1 Необходимо получить зависимость 𝑝(𝑊). Для этого достаточно найти 𝑑0(𝑊) следующим образом: 𝑑0(𝑊)=𝑀[𝐷]=𝑀[𝐷1]+𝑀[𝐷2]+𝑀[𝐷3] где 𝐷1− время между поступлением сообщения и началом окна, 𝑀[𝐷1]=12, 𝐷3− время обслуживания, 𝑀[𝐷3]=1. 𝐷2={0,1,…,𝑊−1} Pr{𝐷2=0}=1𝑊 Pr{𝐷2=1}=1𝑊 Pr{𝐷2=𝑛}=1𝑊 Отсюда, 5  𝑀[𝐷2]=1𝑊∑𝑖𝑊−10=𝑊−12 Следовательно,  𝑑0(𝑊)=12+𝑊−12+1 𝑑0(𝑊)=𝑑0(𝑝) => 12+𝑊−12+1=12+1𝑝 Отсюда следует, что  𝑝=2𝑊+1 => 𝜆кр=𝑀2𝑊+1(1−2𝑊+1)𝑀−1   Графики зависимости 5.1 Сравнение с синхронной системой Как отмечалось ранее, при 𝑀=1 и 𝑊=𝑐𝑜𝑛𝑠𝑡=1 система работает как синхронная, а значит, результаты можно сравнивать с теоретическими значениями. В этом можно убедиться:  Рисунок 2 – График 𝜆вых(𝜆) для 𝑀=1,𝑊=1  6   Рисунок 3 – График 𝑑теор(𝜆) и 𝑑эксп(𝜆) для 𝑀=1,𝑊=1  Рисунок 4 – График 𝑁теор(𝜆) и 𝑁эксп(𝜆) для 𝑀=1,𝑊=1 Как видно, графики совпадают.  5.2 Сравнение с интервальным АЛОХА Как отмечалось ранее, при 𝑊=𝑐𝑜𝑛𝑠𝑡 система работает как интервальный алгоритм АЛОХА, а значит, результаты можно сравнивать с теоретическими значениями. В этом можно убедиться: Согласно полученной формуле, можно рассчитать 𝜆кр и сравнить с экспериментальной.  7  Пусть 𝑀=20 и 𝑊=2𝑀. Тогда 𝜆кр= 0,37 и 𝑑0= 21. Сравним с результатами моделирования:   Рисунок 5 – График 𝜆вых(𝜆) для 𝑀=20,𝑊=40  Рисунок 6 – График  𝑑эксп(𝜆) для 𝑀=20,𝑊=40  Рисунок 7 -Значение 𝑑0 для 𝑀=20,𝑊=40 8   Рисунок 8 – График 𝑁эксп(𝜆) для 𝑀=20,𝑊=40 Как видно, при заданных параметрах экспериментальные значения совпадают с теоретическими.  Пусть 𝑀=10 и 𝑊=𝑀. Тогда 𝜆кр= 0,3 и 𝑑0= 6. Сравним с результатами моделирования:  Рисунок 9 – График 𝜆вых(𝜆) для 𝑀=10,𝑊=10 9   Рисунок 10 – График 𝑑эксп(𝜆) для 𝑀=10,𝑊=10  Рисунок 11 – Значение для 𝑀=10,𝑊=10  Рисунок 12 – График 𝑁эксп(𝜆) для 𝑀=10,𝑊=10 Как видно, при заданных параметрах экспериментальные значения совпадают с теоретическими.  10  5.3 Исследование интервального адаптивного алгоритма Пусть 𝑀=10 и 𝑊0=20.   Рисунок 13 – График 𝜆вых(𝜆) для 𝑀=10,𝑊0=20   Рисунок 14 – График 𝑑эксп(𝜆) для 𝑀=10,𝑊0=20 11   Рисунок 15 – Значение 𝑑0 для 𝑀=10,𝑊0=20  Рисунок 16 – График 𝑁эксп(𝜆) для 𝑀=10,𝑊0=20 Пусть 𝑀=20 𝑊=20.  Рисунок 17 – График 𝜆вых(𝜆) для 𝑀=20,𝑊0=20 12   Рисунок 18 – График 𝑑эксп(𝜆) для 𝑀=20,𝑊0=20  Рисунок 19 – Значение 𝑑0 для 𝑀=20,𝑊0=20   Рисунок 20 – График 𝑁эксп(𝜆) для 𝑀=20,𝑊0=20 13  Как видно. При увеличении числа абонентов задержка увеличивается, а и 𝜆кр уменьшается.  5.4 Сравнение интервального и интервального адаптивного алгоритма. Пусть M=20. Адаптивный интервальный АЛОХА для 𝑊0=1: 𝑑0=1.86 и 𝜆кр=0,34.  Рисунок 21 – Значения 𝑑0 для адаптивного интервального Интервальный АЛОХА для W=2𝑀: 𝑑0=22,8 и 𝜆кр=0,37.  Рисунок 22 -Значения 𝑑0  для интервального Таким образом, адаптивный алгоритм обеспечивает меньшую задержку, но 𝜆кр меньше. Это можно увидеть и по графикам:  14   Рисунок 23 - График сравнения  Рисунок 24 - Графики сравнения Выводы: в ходе выполнения лабораторной работы был исследован и реализован интервальный адаптивный алгоритм АЛОХА, определены характеристики с использованием численных расчетов и имитационного моделирования. Были построены графики зависимостей 𝜆вых(𝜆), 𝑑(𝜆) и 𝑁(𝜆). Анализируя графики, можно сказать, что график 𝜆вых(𝜆) представляется собой прямую под углом 45° из начала координат, которая переходит в прямую, параллельную оси ОХ в точке, советующей 𝜆кр. Графики 𝑑(𝜆) и 𝑁(𝜆) резко возрастают в 𝜆кр. 15  Была рассмотрена работа алгоритма при определенных параметрах в режиме синхронной системы и интервальной АЛОХИ и сделан вывод о том, что графики зависимостей 𝜆вых(𝜆), 𝑑(𝜆) и 𝑁(𝜆) совпали.  Было произведено сравнение адаптивного и неадаптивного алгоритмов. Был сделан вывод о том, что адаптивный алгоритм обеспечивает меньшую задержку, но 𝜆кр меньше. Также были построены графики зависимостей для адаптивного интервального АЛОХИ и сделан вывод о том, что с увеличением числа абонентов 𝑀 критическая интенсивность уменьшается.   16   Листинг ALOHA.java package com.suai;  import com.suai.User.Message; import java.io.FileWriter; import java.util.ArrayList;   public class ALOHA {    private double lambda = 1.4; //   private double T = 100000; // 10000   private int M = 10;   private ArrayList<User> users;   private int Wmax; // МЕНЯТЬ В МОДЕЛИРОВАНИИ     public ALOHA() {     users = new ArrayList<>(M);     for (int i = 0; i < M; i++) {       users.add(new User(lambda / M));     }   }    public void init() {     for (int i = 0; i < M; i++) {       User cur = users.get(i);       cur.getMessageQueue().clear();       cur.setLambda(lambda / M);       cur.setWmax(Wmax);     }   }    private int systemOutput(int window) { // у всех ли надо менять, или только у участников конфликта     int readyToSend = 0;     for (int i = 0; i < users.size(); i++) {       if (readyToSend >= 2) {         break;       }       User cur = users.get(i);       if (cur.isReady(window)) {         readyToSend++;       }     }     if (readyToSend == 0) {       return 0; // П     } 17      if (readyToSend == 1) {       return 1; // У     }     return 2; // К   }    public void empty() {     Wmax = (int) (Math.max((1), (double) (Wmax) / 2)); // адаптивный    // Wmax = (int) (Math.max((Wmax), (double) (Wmax) / 2)); // обычный интервальный     for (int i = 0; i < M; i++) {       users.get(i).empty(Wmax);     }   }    public void conflict(int curWindow) {     Wmax = Math.min((2 * M), 2 * Wmax); // адаптивный     //Wmax = Math.min((Wmax), 2 * Wmax); // обычный интервальный     for (int i = 0; i < M; i++) {       users.get(i).conflict(Wmax, curWindow);     }   }    private double theoreticalD() {     double res = theoreticalN() / lambda + 0.5;     return res;   }    private double theoreticalN() {     double res = (lambda * (2 - lambda)) / (2 * (1 - lambda));     return res;   }    public void channelModeling() {     for (lambda = 0.05; lambda <= 0.4; lambda += 0.05) {       Wmax = 20; // МЕНЯТЬ ТУТ       init();       double d = 0;       double N = 0;       double served = 0;       for (int t = 0; t < T; t++) {         int readySub = systemOutput(t);         if (readySub == 0) {           for (int i = 0; i < users.size(); i++) {             User cur = users.get(i);             empty();           }         } else {           if (readySub == 2) {             for (int i = 0; i < users.size(); i++) { 18                User cur = users.get(i);               conflict(t);             }           } else {             for (int i = 0; i < users.size(); i++) {               User cur = users.get(i);               if (cur.getMessageQueue().size() != 0) {                 if (cur.isReady(t)) {                   Message m = cur.getMessageQueue().pollFirst();                   d += m.getTimeExit() - m.getTimeArrival(); //???                   served++;                 }               }             }           }         }         for (int i = 0; i < M; i++) {           User cur = users.get(i);           cur.generateNewMessage(t);           N += cur.getMessageQueue().size();         }       }       System.out.println("lambda = " + lambda);       System.out.println("lambdaOut = " + served / T);       writer("l.txt", lambda, served / T);       if (M == 1 && Wmax == 1) {         System.out.println("N_t = " + theoreticalN());         writer("N_t.txt", lambda,theoreticalN());       }       System.out.println("N_e = " + N / T);       writer("N.txt", lambda, N / T);       if (M == 1 && Wmax == 1) {         System.out.println("d_t = " + theoreticalD());         writer("d_t.txt", lambda, theoreticalD());       }       System.out.println("d_e = " + d / served);       writer("d.txt", lambda, d / served);     }   }    public void cleaner() {     try {       String path = "C:/Users/iyush/IdeaProjects/IntervalAdaptiveALOHA/src/com/suai/";       FileWriter fileWriterN = new FileWriter(path + "N.txt");       FileWriter fileWriterD = new FileWriter(path + "d.txt");       FileWriter fileWriterN_t = new FileWriter(path + "N_t.txt");       FileWriter fileWriterD_t = new FileWriter(path + "d_t.txt");       FileWriter fileWriterL = new FileWriter(path + "l.txt");       fileWriterN.close(); 19        fileWriterD.close();       fileWriterN_t.close();       fileWriterD_t.close();       fileWriterL.close();     } catch (Exception e) {       System.out.println(e.getMessage());       e.printStackTrace();     }    }    public void writer(String fileName, double x, double y) {     try {       FileWriter file = new FileWriter(           "C:/Users/iyush/IdeaProjects/IntervalAdaptiveALOHA/src/com/suai/" + fileName, true);       file.write(x + " " + y + "\n");       file.flush();     } catch (Exception e) {       System.out.println(e.getMessage());       e.printStackTrace();     }   }    public static void main(String[] args) {     ALOHA aloha = new ALOHA();     aloha.cleaner();     aloha.channelModeling();   } }  User.java package com.suai;  import java.util.Collections; import java.util.Comparator; import java.util.HashMap; import java.util.LinkedList;  public class User {    public class Message {      private double timeArrival;     private double timeExit;      public double getTimeExit() { 20        return timeExit;     }      public double getTimeArrival() {       return timeArrival;     }      public int generateW() { // генерация окна для передачи       double tmp = Math.random();       double prob = (double) 1 / Wmax; // равновероятны       double step = (double) 1 / Wmax;       int w = 0;       for (; w < Wmax; w++) {         if (tmp <= prob)           break;         prob += step;       }       return w + 1;     }   }     private HashMap<Integer, Double> prob;   private double lambda;   private LinkedList<Message> messageQueue;   private double Wmax;   private int M;    public LinkedList<Message> getMessageQueue() {     return messageQueue;   }     public User(double l) {     prob = new HashMap<>();     lambda = l;     messageQueue = new LinkedList<>();     getProb();   }    public void empty(int Wmax) {     this.Wmax = Wmax;   }    public void conflict(int Wmax, int curWindows) {     this.Wmax = Wmax;     if (messageQueue.size() != 0) {       if (isReady(curWindows))       messageQueue.getFirst().timeExit = 0;     } 21    }    public void setLambda(double l) {     lambda = l;     getProb();   }    public void setWmax(double w) {     Wmax = w;   }    public boolean isReady(int curWindow) {     if (messageQueue.size() != 0) {       Message first = messageQueue.getFirst();       if (first.timeExit == 0) {         first.timeExit = 1 + curWindow + first.generateW() - 1;       }     }     for (int i = 0; i < messageQueue.size(); i++) {       if (messageQueue.getFirst().timeExit == (curWindow + 1)) { //!!!         return true;       }     }     return false;   }     public long factorial(int number) {  // факториал     long result = 1;     for (int factor = 2; factor <= number; factor++) {       result *= factor;     }     return result;   }    public double prob(int num) { // подсчет вероятности для i     double prob = (Math.pow(lambda, num) / factorial(num)) * Math.exp((-1) * lambda);     if (prob <= Math.pow(10, -5)) {       return 0;     }     return prob;   }     public void getProb() { // генерация вероятностей для числа абонентов     for (int count = 0; ; count++) {       double prob = prob(count);       if (prob == 0) { 22          break;       }       this.prob.put(count, prob);     }   }    public void generateNewMessage(int t) { // генерация числа сообщений и их запись в очередь     double tmp = Math.random();     double sum = 0;     int newM = 0;     for (; newM < prob.size(); newM++) {       sum += prob.get(newM);       if (tmp <= sum) {         break;       }     }     for (int k = 0; k < newM; k++) {       double time = Math.random();       Message m = new Message();       m.timeArrival = time + t;       messageQueue.add(m);     }     Collections.sort(messageQueue, new MessageComparator()); // сортировка по времени выхода   }    private class MessageComparator implements Comparator<Message> {      @Override     public int compare(Message a, Message b) {       if (a.getTimeArrival() < b.getTimeArrival()) {         return -1;       }       if (a.getTimeArrival() == b.getTimeArrival()) {         return 0;       }       return 1;     }   } }     