2  ОГЛАВЛЕНИЕ  Введение ......................................................................................................................................... 3 Описание алгоритма ...................................................................................................................... 4 Выбор параметров ....................................................................................................................... 12 Анализ стойкости ........................................................................................................................ 14 Сложность реализации  ............................................................................................................... 15  Заключение ................................................................................................................................... 19 Список использованной литературы ......................................................................................... 20                            3  ВВЕДЕНИЕ  Пост-квантовый алгоритм шифрования ThreeBears основан на методе Любашевского-Пейкерта-Регева и криптосистеме Диня с обучением с ошибками в кольце (RLWE). Также он основан на алгоритмах Kyber и NewHope. Алгоритм Kyber использует в задачу модульного обучения с ошибками (MLWE). Создатели алгоритма заменили кольцо полиномов, лежащее в основе этого модуля, целыми числами по модулю обобщенного числа Мерсена, превратив его в целочисленное модульное обучение с ошибками (далее I-MLWE).  Целью создания алгоритма ThreeBears является поощрение исследования потенциально желательных, но менее традиционных решений. Именно поэтому ThreeBears использует I-MLWE вместо MLWE, закрытый ключ является только стартовым параметром, создатели алгоритма не использовали хэш для подтверждения открытого текста.                       4  ОПИСАНИЕ АЛГОРИТМА  Обозначения Пусть  обозначает целые числа, а /N— кольцо целых чисел по модулю некоторого целого числаN. Для элемента/xNза()resx обозначим его значение в виде целого числа из множества {0,...,1}N−. Для вещественного числа r r(«округление r вниз») — наибольшее целое число r; r(«округление r вверх») — наименьшее целое число r; и r — округление r до ближайшего целого числа. Пусть nT обозначает множество последовательностей из n элементов, каждый элемент которых имеет тип T. Для одной такой последовательности используется обозначение ,,...,abz или 10niiS−=. Если S — последовательность из n элементов и 0in, тогда iS — ее i-ый элемент. Код, исправляющий ошибки, ниже описывается в терминах битовых последовательностей, то есть элементов вида {0,1}n. Пусть ab– операция побитового исключающего или для двух битовых последовательностей. Если a и b имеют разную длину, короткая последовательность дополняется нулевыми элементами до длины другой последовательности. Операция побитого исключающего или для множества последовательностей обозначается как S.  Кодирование Пусть B обозначает множество байт, то есть множество{0,...,255}. Открытые ключи, закрытые ключи и шифртексты хранятся и передаются в виде последовательностей байтов фиксированной длины. То есть, как элементы  nBс некоторым значением n, которое зависит от параметров системы.  В данном алгоритме последовательности байт в основном представлены в порядке от младшего к старшему разряду и обладают постоянной длиной, что означает, что первый элемент последовательности всегда будет представлять младший разряд. Кроме того, количество элементов в последовательности всегда задается типом элементов и набором параметров, так что никакое дополнительное изменение длин последовательной не используется.  5  Элемент z из /N кодируется как последовательность байт B, упорядоченная от младшего к старшему, длиной 256():logNN=bytelength, такая, что  ()10256()NiiiBresz−==bytelength Для декодирования вычисляются 256modiiBN без проверки того, что закодированный остаток меньше N.  Зашифрованные с помощью ThreeBears ключи содержат последовательность 4-битных полубайт (nibbles в описаниях алгоритмов), то есть элементов множества{0,...,15}. Эта последовательность кодируется с помощью объединения по два полубайта и формирования множества 1byte, в котором каждая последовательность упорядочена от младшего к старшему разряду. Последовательность полубайт s кодируется как ()/2221016lengthsiiiss+=+  Параметры Данный экземпляр алгоритма ThreeBears имеет множество параметров. Около половины из них — это длины различных стартовых параметров, зафиксированные в соответствии с требованиями безопасности. Список параметров приведен в таблице 1. Эти параметры затрагивают действия каждой функции в данной курсовой работе.  Таблица 1. Общие параметры алгоритма. Описание Название Значение Независимые параметры Версия спецификации version 1 Длина секретного ключа (байт) privateKeyBytes 40 Длина стартового параметра  матрицы (байт) matrixSeedBytes 24 Длина стартового параметра кодирования (байт) encSeedBytes 32 Длина вектора инициализации  (байт) ivBytes 0 6  Длина разделяемого секрета (байт) sharedSecretBytes 32 Количество бит на представление числа lgx 10 Размерность кольца D 312 Размерность модуля d 2;4 Дисперсия шума 2 0,25;1 Точность округления при шифровании l 4 Кол-во бит, используемых для прямого исправления ошибок fecBits 18 Защита от CCA cca 0;1 Производные параметры Основание системы счисления x 2lgx Модуль N /21DDxx−− Уточняющий элемент clar /21Dx−  Параметры для рекомендованных экземпляров приведены в таблице 2. Каждая система имеет варианты обмена ключами с защитой от CPA и защитой от CCA. Для каждой системы создатели алгоритма оценили вероятность сбоя, сложность атаки экземпляра с помощью решетчатых атак и сложность атаки по выбранному шифртексту с помощью квантового компьютера.  Таблица 2. Рекомендованные параметры ThreeBears. Система d cca 2 Вероятность ошибки Стойкость против решетчатых атак Обычная        Квантовая      Класс BabyBear 2 0 1 1 9/16 5815622−− 168 154 153 140 II II MamaBear 3 0 1 7/8 13/32 5120622−− 262 235 238 213 V IV 7  PapaBear 4 0 1 3/4 5/16 5225622−− 351 314 318 280 V V  Также создатели алгоритма определили два набора «игрушечных» параметров, показанных в таблице 3.  Таблица 3. "Игрушечные" параметры ThreeBears. Система lgx D d cca 2 Вероятность ошибки Стойкость TeddyBear 9 240 1 1 3/4 582− 60 DropBear 10 312 2 1 2 62− 184  Инкапсуляция Пусть ()bnseq— последовательность бит целого числа n длины b в порядке от младшего к старшему разряду. Для бита a и последовательности B пусть будет ()10:lengthBiiaBaB−== Для битовых последовательностей R и s длиной 1b+ и b соответственно, пусть 01(,):(())biiRsssR==step Пусть (,)iRsstep обозначает i-ую итерацию (,)Rstep, примененную к s. Тогда 18FecEncodeдобавляет 18 бит проверочной информации таким образом, как показано на рисунке 1.   Рисунок 1. FEC кодирование. 8   Декапсуляция Декодирование осуществляется сложнее, потому что для обнаружения двух ошибок необходимо решить квадратное уравнение. Пусть 91:(0211)Qx+=seq. Для 9-разрядных последовательностей a и b определим следующую 9-разрядную последовательность: 880:((,))iiiabbQa−==step Операции  и  определяют поле из 92 элементов с нейтральным по сложению элементом 0 и нейтральным по умножению элементом 9()seq0x100. Знаком  обозначается умножение с помощью алгоритма Монтгомери. Определим naкак n-ую степень a, полученную с помощью операции умножения . Остальная часть алгоритма декодирования показана на рисунке 2.   Рисунок 2. FEC декодирование. 9  Генерация ключей.  Генерация ключей определяется так, чтобы секретный ключ представлял собой байтовую строку, заполненную случайными, равномерно распределенными значениями. Реализации онлайн-обмена ключами могут кэшировать промежуточные значения, такие, как секретный вектор или матрица, но алгоритм ThreeBears достаточно быстр, чтобы в этом не было необходимости.   Рисунок 3. Генерация ключей.  Шифрование Функция шифрования показана на рисунке 4. Она включает в себя детерминированную версию, которая используется для дешифрования с защитой от CCA. Как и в случае с функцией генерации ключей функция инкапсуляции просто передает случайное начальное значение и вектор инициализации в функцию EncapsDet. 10  В реализации шифрования с защитой от CCA шум получается из стартового параметра, и этот же стартовый параметр используется в качестве открытого текста, как того требует преобразование Фудзисаки-Окамото. В ином же варианте реализации и шум, и открытый текст получаются из стартового параметра путем применения хэш-функции 2.H   Рисунок 4. Шифрование.   11  Дешифрование Алгоритм дешифрования, Decapsulate, принимает в качестве входных параметров закрытый ключ skи шифртекст. Он возвращает либо разделенный секрет, либо символ сбоя ⊥, как показано на рисунке 5.   Рисунок 5. Дешифрование.    12  ВЫБОР ПАРАМЕТРОВ  Стартовые параметры Размеры стартовых параметров в данном алгоритме рассчитаны на общее пространство поиска 2562 или больше. Стартовые параметры для шифрования и передаваемые ключи составляют 256 бит. Создатели алгоритма не считают, что многоцелевые атаки по восстановлению ключей будут являться существенной проблемой, поскольку на обычных вычислительных устройствах для восстановления одного из Tключей методом перебора потребовалось бы 2562/T времени, и данный метод не допускает значительного квантового ускорения. Но защита генерации ключей практически беззатратна и осуществляется использованием секретных ключей длины 320 бит (40 байт). Это означает, что классическая многоцелевая атака с целью восстановления ключей на 642ключа будет иметь сложность 2562. Так как стартовый параметр шифрования составляет 256 бит, существует многоцелевая атака, смысл которой состоит в получении множества шифртекстов, зашифрованных с помощью одного ключа. Чтобы осложнить применение такой атаки, нужно прикрепить вектор инициализации (также IV) к каждому зашифрованному тексту. Однако параметры, рекомендованные создателями алгоритма, устанавливают длину IV равной 0 байт (т.е. вектор не используется), потому что многоцелевая атака методом полного перебора, по их мнению, не представляет реальной угрозы. Длина стартового параметра для матрицы составляет 192 бита. Это значение выбрано для того, чтобы стартовые параметры матрицы почти наверняка никогда не совпадали даже при генерации 642 ключей. И даже если они совпадут, это даст противнику весьма малое преимущество.   Модуль Значение N было выбрано простым, чтобы исключить атаки, основанные на подкольцах. Было бы прекрасно, если бы N было простым числом Ферма, но простых чисел Ферма нужного размера не существует. Следующим очевидным выбором могли бы стать простые числа Мерсенна 2121pkDx−=−, где в лучшем случае k может быть 1: оно не может быть 0, потому что p — простое число, но lgDx является составным. Следовательно, уменьшение по модулю простого числа Мерсенна по крайней мере удвоит амплитуду шума и увеличит его дисперсию в четыре раза. 13  На данный момент лучший вариант — это простое число, основанное на принципе «золотого сечения»: /21DDxx−−. Умножение на /2:1Dx=−clar и уменьшение по модулю этого простого числа увеличит дисперсию на 3/2 в числах, находящихся в зоне середины диапазона. При таком усилении требуется выбрать 102x для приемлемой вероятности отказа и 256D для передачи 256-битного ключа. Это оставляет варианты: 26001300221+− и 31201560221−− Если небольшая дисперсия шума алгоритма ThreeBears вызывает беспокойство, возможно использовать тот же большой модуль с 260D=и 122x=, что увеличит значение шума. Это будет полезно, если комбинаторные атаки станут серьезной угрозой. Но согласно текущим оценкам атаковать алгоритм с параметрами 312D=и 102x=гораздо сложнее.  Точность округления Параметр точности округления l при шифровании — это компромисс. Большее значение l увеличивает размер шифртекста, но уменьшает вероятность сбоя. Это позволяет добавлять больше шума, что повышает безопасность. По оценкам безопасности, произведенным создателями алгоритма, наилучший компромисс между уровнем безопасности и размером шифртекста достигается при 3l=, но при  4l=ситуация лишь немного хуже. Параметр l был выбран равным 4, потому что это упрощает реализацию.  Дисперсия Дисперсия шума была выбрана как простая двоичная дробь. Создатели алгоритма стремились установить вероятность отказа для экземпляров, защищенных от CPA, ниже 502−. Для экземпляров с защитой от CCA уровень шума устанавливается таким образом, чтобы частота отказов составляла около 2−, где  — предполагаемый уровень битовой стойкости. Для обычного злоумышленника никакая атака с использованием одного ключа не может привести к сбою за ожидаемое время, меньшее, чем 1/2. Известные атаки с ограниченными запросами намного слабее, чем эта, даже при использовании квантового компьютера. Для BabyBear  устанавливается ближе к  в надежде, что, поскольку как оценка защиты от решетчатых атак, так и оценка защиты от CCA занижены, BabyBear может фактически достигнуть уровня безопасности III. Создатели алгоритма также хотели сохранить его значение значительно ниже 1282−, чтобы атака с отказом была совершенно невозможной, даже с использованием квантового компьютера и значительным улучшением стратегии атаки. 14  Для других систем  устанавливается чуть выше целевого уровня безопасности. Это связано с философией снижения рисков. На самом деле никто не беспокоится о злоумышленнике, выполняющем 1922 операции, но все беспокоятся о возможных прорывах, которые сократят работу до посильного уровня. Атаки CCA имеют меньше возможностей для улучшения, чем решетчатые атаки, и поэтому с меньшей вероятностью повлияют на практическую безопасность ThreeBears. В данном случае необходимо было только убедиться, что частота отказов не является подтвержденной слабостью. Есть некоторые недостатки в использовании такой малой дисперсии, такие как возможность применения гибридных атак. Но Миччанчо и Пейкерт предполагают, что даже двоичный шум должен быть безопасным до тех пор, пока доступное количество LWE выборок для противника невелико. В данном случае противник видит только 1d+ образец колец размерности D, которые, по крайней мере, достаточно малы, чтобы применение известных атак не было возможным.  АНАЛИЗ СТОЙКОСТИ  Задача I-MLWE Безопасность ThreeBears основана на сложности задачи обучения с ошибками по модулю целого числа (I-MLWE). Было доказано, что асимптотически целочисленные задачи RLWE и полиномиальные задачи RLWE имеют одинаковую сложность, и это доказательство должно быть перенесено непосредственно на I-MLWE. Как это часто бывает с уменьшением защиты от решетчатых атак, это доказательство является асимптотическим и неприменимо к практическим параметрам. Но также нет причин для того, чтобы предполагать, что задача I-MLWE проще, чем P-MLWE, поэтому создатели алгоритма ожидают, что эти две проблемы будут схожи по практической сложности.  Преобразование CCA При анализе алгоритма с использованием модели случайного оракула может быть доказано, что для противника A класса IND-CCА, который выполняет q квантовых запросов на глубине d к cSHAKE в качестве квантово-доступного случайного оракула, существует квантовый алгоритм B, использующий лишь немного больше ресурсов, чем ,Aтакой, что 15  83844()2(1)(()/2)/2                       16.INDCCAIMLWEAdvAdAdvBqqdqdnegl−−−+++++encryptionSeedBytesprivateKeyBytes Где • ()INDCCAAdvA− является преимуществом различения против метода шифрования ключа для A. • ()IMLWEAdvB− — это преимущество различения B против (1)ddIMLWE+−. • q — это количество раз, когда злоумышленник вызывает cSHAKE. •  — вероятность отказа. • .negl — число намного меньшее, чем другие переменные, по крайней мере, для рекомендуемых параметров.  Создатели алгоритма не моделировали атаки, которые увеличивают вознаграждение противника (например, путем взлома многих ключей в пакете). Они также не анализировали многоцелевые I-MLWE атаки ни в одной из этих моделей. Существует некоторая работа по пакетным атакам для поиска коротких векторов решеток в кольце, но ничего более, что могло бы обеспечить пакетную атаку на ThreeBears.  СЛОЖНОСТЬ РЕАЛИЗАЦИИ  Время Обе процедуры генерации ключей и шифрования в алгоритме ThreeBears требуют выборки случайной матрицы размерности dd и умножения ее на вектор. Для используемого в данном алгоритме N подходит умножение Карацубы, поэтому эти операции занимают приблизительно 2log322((log)/)OdNb времени на процессоре с b-разрядным умножителем. Это сопоставимо с шифрованием RSA с небольшой открытой экспонентой. Для шифрования и дешифрования требуется точечное векторное произведение длины d, что в d раз быстрее. Кроме того, генерация ключей и шифрование требуют выборки размером 2dи 21d+ элементов шума соответственно. Чтобы измерить конкретную производительность, создатели алгоритма провели сравнительный анализ кода алгоритма на нескольких разных платформах, что показано в таблице 4. Предполагается, что реализации, оптимизированные по скорости, вероятно, будут обменивать память на время дешифрования, кэшируя некоторые компоненты открытого и закрытого ключей. Объем информации, подлежащей кэшированию, зависит от ограничений приложения. Однако предоставленные реализации ничего не кэшируют. 16  Создатели алгоритма считают, что реализация на Skylake и Cortex-A53 достаточно близка к оптимальной, но, возможно, тщательная настройка алгоритма умножения может снизить время еще на 25%. Для реализации на Cortex-A8 можно оптимизировать алгоритм умножения и обеспечить значительное улучшение. Для реализации на Cortex-M4 возможности оптимизации тщательно не изучались. В ходе изучения создатели обнаружили, что FEC прибавил от 0,1% до 2% времени к полученному результату. Фактически, более значительные накладные расходы от добавления FEC заключаются в том, что он создает больший шум, что может привести к большему количеству итераций в функции шума. Таблица 4. Время работы основных функций алгоритма в циклах. Система Защита от CPA Защита от CCA KeyGen Enc Dec KeyGen Enc Dec Skylake  BabyBear 41k 62k 28k 41k 60k 101k MamaBear 84k 103k 34k 79k 90k 156k PapaBear 124k 153k 40k 118k 145k 211k Cortex-A53 BabyBear 153k 211k 80k 154k 210k 351k MamaBear 302k 377k 11k 297k 369k 566k PapaBear 500k 594k 141k 492k 582k 840k Cortex-A8 BabyBear 344k 501k 176k 345k 495k 810k MamaBear 729k 943k 260k 720k 931k 1379k PapaBear 1234k 1511k 319k 1225k 1502k 2134k Cortex-M4 (высокая скорость) BabyBear 644k 841k 273k 644k 824k 1299k MamaBear 1266k 1521k 381k 1257k 1494k 2174k PapaBear 2095k 2409k 488k 2082k 2378k 3272k Cortex-M4 (малые затраты памяти) BabyBear 744k 1039k 273k 744k 1022k 1495k MamaBear 1564k 1967k 381k 1548k 1929k 2609k PapaBear 2691k 3201k 488k 2663k 3150k 4044k   17  Размер кода Был измерен общий размер кода на каждой платформе для реализации MamaBear. Итоговые размеры приведены в таблице 7. Реализации для разных параметров могут отличать по размеру.  Таблица 5. Размер выходных данных алгоритма в байтах. Система Закрытый ключ Открытый ключ Шифртекст BabyBear 40 804 917 MamaBear 40 1194 1307 PapaBear 40 1584 1697  Таблица 6. Размер кода для MamaBear в байтах. Компонент Skylake Cortex-A53 Cortes-A8 Cortex-M4 Скорость Память Вычисления 2194 1892 1424 930 930 FEC Меласа 655 541 431 417 417 cSHAKE 1488 900 866 777 777 Основная система 3206 2843 2133 2187 1951 Всего 7543 6176 4854 4311 4075  Использование памяти С помощью специальных инструментов было измерено использование стековой памяти каждой функции верхнего уровня для реализаций на Skylake и Cortex-M4. Эти измерения включали память, используемую алгоритмом ThreeBears во время работы, включая хэш-контексты и вызовы функций, но не входные или выходные данные. Результаты приведены в таблице 7, их следует рассматривать как приблизительные.  Таблица 7. Использование памяти алгоритмом в байтах, исключая входные и выходные данные. Система Защита от CPA Защита от CCA Keygen Enc Dec Keygen Enc Dec Skylake (высокая скорость) BabyBear 6216 6632 4232 6216 6632 8184 MamaBear 9112 9528 4632 9112 9560 11512 PapaBear 12856 13272 5048 12856 13304 15672 18  Skylake (малые затраты памяти) Все реализации 2392 2424 2168 2392 2424 3080 Cortex-M4 (высокая скорость) BabyBear 2760 2832 2080 2760 2832 4944 MamaBear 3256 3312 2080 3256 3320 5904 PapaBear 3736 3800 2080 3736 3800 6864 Cortex-M4 (малые затраты памяти) Все реализации 2288 2352 2080 2288 2352 3024                           19  ЗАКЛЮЧЕНИЕ  В данной пояснительной записке было приведено подробное описание алгоритма Three Bears, участника конкурса национального института стандартов и технологий NIST по выбору квантово-устойчивых криптоалгоритмов для стандартизации. Также были описаны рекомендуемые параметры кода и известные атаки.                               20  СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ  1. Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On ideal lattices and learning with errors over rings. In Henri Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 1–23. Springer, Heidelberg, May / June 2010. 2. Mike Hamburg. Ed448-goldilocks, a new elliptic curve. Cryptology ePrint Archive, Report 2015/625, 2015. 3. Joppe Bos, Leo Ducas, Eike Kiltz, Tancrede Lepoint, Vadim Lyubashevsky, John M. Schanck, Peter Schwabe, and Damien Stehle. CRYSTALS – kyber: a CCA-secure module-lattice based KEM. Cryptology ePrint Archive, Report 2017/634, 2017. 4. Erdem Alkim, Leo Ducas, Thomas Poppelmann, and Peter Schwabe. Post-quantum key exchange - a new hope. Cryptology ePrint Archive, Report 2015/1092, 2015. 5. Jintai Ding, Xiang Xie, and Xiaodong Lin. A simple provably secure key exchange scheme based on the learning with errors problem. Cryptology ePrint Archive, Report 2012/688, 2012.  