Цель работы Реализовать алгоритм хеширования Провести эксперименты: Нахождение второго прообраза. Нахождение коллизий. Построить графики зависимости среднего значения сложности второго прообраза и коллизии от количества взятых бит. Оценить полученные графики. Алгоритм Алгоритм состоит из пяти шагов: Добавление недостающих битов Необходимо, чтобы количество бит соответствовало где Добавление длины сообщения Длина добавляется в битном представлении так, что Инициализация буфера Обработка сообщений блоками по слов Определим вспомогательные функции Теперь обозначим как операцию где слово из обрабатываемого блока. Первый раунд: Теперь обозначим как операцию где слово из обрабатываемого блока. Второй раунд: Теперь обозначим как операцию где слово из обрабатываемого блока. К значениям прибавить их состояния в начале блока. Формирование кэша Рис. Одна операция Пример: Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Исходная строка: Результат работы программы: Полученный хэш совпадает с теоретическим значением. Нахождение второго прообраза и коллизий Возьмем слово-пароль из х слов, одно из них состоит из нулей. Х Необходимо найти от него хеш взять от полученного хеша первые бит, обозначив последовательность у0. Далее случайным образом сгенерировать зависит от двух условий, описанных ниже) сообщений, найти от каждого хеш и взять от каждого хеша первые бит, получив последовательность у1, у2,..., уN-1. Для нахождения сложности второго прообраза необходимо найти такой уi, что уi у0. Посчитать количество шагов, которое потребовалось, чтобы найти уi Для нахождения коллизии необходимо найти в полученной последовательности такие уi и уj, что уi уj. Посчитать количество шагов, которое потребовалось, чтобы найти эту пару. Проделав эксперимент раз, получим средние значения сложности второго прообраза и сложности коллизии. Рис.2 график зависимости среднего значения сложности второго прообраза от количества взятых бит. Рис.3 график зависимости среднего значения сложности коллизии от количества взятых бит. Анализируя данные графики, можно увидеть прямую зависимость среднего значения сложности второго прообраза и коллизии от количества бит. При увеличении с до бит, сложность второго прообраза возросла в раз, а сложность коллизии в Это связано с тем, что для нахождении коллизии, нужно использовать количество шагов, необходимое для сравнения каждого элемента последовательности с каждым О(n а для второго прообраза сравнить последовательность с одним ее элементом О(n)). Так же на формирование сложности влияют внутренние шаги программного вычисления. Поэтому средняя сложность коллизии превышает сложность второго прообраза и функция растет быстрее. Эксперимент был проведен раз при количестве сообщений равном Так как сообщения генерировались случайным образом, при заданных параметрах наблюдалась стойкость алгоритма ко второму прообразу для бит. При количестве сообщений и более, стойкость не наблюдалась. Вывод В ходе данной лабораторной работы был программно воспроизведен алгоритм хэширования а так же проведен анализ устойчивости данного алгоритма к нахождению второго прообраза и коллизий. Можно сделать следующие выводы о проделанной работе: Так как результат программы совпадает с теоретическим значением, можно сказать, что алгоритм реализован верно. В качестве аналитического эксперимента, была исследована зависимость сложности второго прообраза и коллизий от количества бит. По данным графиков была найдена прямая зависимость от данных величин. Функция сложности коллизии растет быстрее функции сложности второго прообраза. Самая быстрая хэш-функция, оптимизирована для битных машин среди семейства функций, содержит три цикла по шагов каждый. В году был описан алгоритм взлома поэтому на сегодняшний день данная функция не рекомендована для использования с реальными приложениями. Список источников А.Л. Чмора Современная прикладная криптография" Черчхаус. Коды и шифры 