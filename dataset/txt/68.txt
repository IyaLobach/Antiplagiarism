Содержание Содержание2 Введение3 1. Алгоритм4 1.1 Описание алгоритма4 1.2 Псевдокод7 1.3. Анализ сложности алгоритма7 2. Инструкция пользователя7 3 Тестовые примеры9 Заключение15 Список использованных источников16    2  Введение Задачейданнойкурсовойработыявляетсяразработкапрограммы,которая        реализовывалабыбыстрыйалгоритмпоискаминимальногоостовногодерева        (АлгоритмКрускала).​Остовноедеревографа—этодерево,подграфданногографа,с            темжечисломвершин,чтоиуисходногографа.Неформальноговоря,остовноедерево             получаетсяизисходногографаудалениеммаксимальногочисларёбер,входящихв          циклы,нобезнарушениясвязностиграфа.Наиболееизвестнымиалгоритмамидля          решенияданнойзадачиявляютсяалгоритмДейкстры,алгоритмПримаиалгоритм          Крускала.ОднакоалгоритмКрускаладостаточнопроствсвоейидееиреализации.Он            заключаетсявсортировкевсехрёбервпорядкевозрастаниядлины,ипоочерёдному           добавлениюихвминимальныйостов,еслионисоединяютразличныекомпоненты          связности.ХотяобаалгоритмаработаютзаO(Mlog⁡N),существуютконстантные         различиявскоростиихработы.Наразреженныхграфах(количестворёберпримерно           равноколичествувершин)быстрееработаеталгоритмКрускала,ананасыщенных          (количестворёберпримерноравноквадратуколичествувершин)-алгоритмПрима          (при использовании матрицы смежности). На практике чаще используется алгоритм Крускала. На рисунке 1 приведен пример решения данной задачи:  Рисунок 1. “Пример работы алгоритма”  3  1. Алгоритм 1.1 Описание алгоритма Онподпадаетподклассалгоритмов,называемых​«жадными»алгоритмами​,         которыенаходятлокальныйоптимальныйвариантвнадежденайтиглобальный         оптимальный вариант.  Мыначинаемсреберснаименьшимвесомипродолжаемдобавлятьребра,пока            не достигнем нашей цели. Шаги для реализации алгоритма Крускала следующие: 1. Сортировать все ребра по возрастанию. 2.Возьмитереброснаименьшимвесомидобавьтееговостовное          дерево. Если добавление ребра создало цикл, то отклоните это ребро. 3.Продолжайте добавлять ребра, пока не достигнете всех вершин. Болееформально:пустьмыуженашлинекоторыерёбра,входящиев          минимальныйостов.Утверждается,чтосредивсехрёбер,соединяющихразличные         компонентысвязности,вминимальныйостовбудетвходитьребросминимальной          длиной. ДляреализацииалгоритмаКрускаланеобходимоуметьсортироватьрёбрапо         возрастаниюдлины.Такжелюбойминимальныйалгоритмостовногодеревавращается         вокругпроверки,создаетлиреброциклилинет.Наиболеераспространенныйспособ           выяснитьэто-алгоритмUnionFInd.АлгоритмUnion-Findразделяетвершинына            кластерыипозволяетнампроверить,принадлежатлидвевершиныодномукластеру           или нет, и, следовательно, решить создает ли добавление ребра цикл. Визуализация работы алгоритма Крускала:  Рисунок 2.1.   4  Начните с взвешенного графа.  Рисунок 2.2. Выберитереброснаибольшимвесом,еслижеихбольшеодного,товыберите          любое.  Рисунок 2.3. Выберите следующее ребро с наименьшим весом и добавьте его.  Рисунок 2.4. Выберитеследующеереброснаименьшимвесом,котороенесоздаетцикли           добавьте его.  5  Рисунок 2.5. Выберитеследующеереброснаименьшимвесом,котороенесоздаетцикли           добавьте его.  Рисунок 2.6. Повторяйте до тех пор, пока не получите остовное дерево.   6  1.2 Псевдокод string text - текст, в котором будет происходить поиск. string str - строка, которую мы будем искать. vector<int> index - результирующий вектор с позициями  1.3. Анализ сложности алгоритма ВхудшемслучаевремяработыалгоритмаКрускала—O(MlogN),гдеM-            количестворёберграфа,аN-количествовершин,таккаксложностьфункцииfind_set             составляетO(logN).Такимобразом,наиболееоптимальнымвариантомиспользования        алгоритмаявляетсяприменениеегокразреженнымграфам,тоестькграфам,у            которых ​количество рёбер примерно равно количеству вершин. 2. Инструкция пользователя Запускпрограммыпроизводитсячерезкоманднуюстроку.Отпользователя        требуетсяподатьвпрограммупутькчетырёмфайлам.Первыйфайлявляетсявходным            исодержитсамграф.Второйитретийфайлиспользуютсядлявыводарезультата            работыпрограммы.Вовторомбудетсодержатьсявывод,совместимыйспрограммой          Graphviz(файлtemp.dot).Втретьембудетавтоматическипрописыватьсяконсольная         7   void​ Graph::kruskal()  {   ​int​ i, uRep, vRep;   сортировка длин рёбер по возрастанию();   ​for​ (для каждого ребра) { //O(M)     uRep = ищем связь(начало ребра); // O(logN)     vRep = ищем связь(конец ребра);     ​if​ (uRep не соответствует vRep) {       добавляем i-ое ребро(); ​// добавляем в дерево       объединение вершин(uRep, vRep);     }   } } командагенерацииизображенияграфа,послечегоданныйфайлнужнобудетпросто           запустить.(MyGraph.cmd).Четвертымуказываетсяпутькрасположениюпрограммы        Graphviz.Послеэтоговтойжепапкепоявитсяфайлсостовнымдеревомграфа,             который наглядно показывает результат работы программы (файл temp.png).  Шаблон команды: Kruskal.ехе <input> <output1> <output2> <output3>, где: input - путь к файлу, где граф представлен списком рёбер. output1-путькфайлу,кудабудетвыводитьсяграфдляпостроениявGraphviz.             (temp.dot) output2-путькконсольномуфайлуMyGraph.cmd,которыйпризапуске          генерирует требуемое нам изображение. output3 - путь к расположению самой папки Graphviz.   8  3 Тестовые примеры CD D:\myprojects\Kruskal\kruskal\Debug d:\\myprojects\\Kruskal\\kruskal\\kruskal\\graph.txt  d:\\Graphviz\\temp.dot d:\\Graphviz\\MyGraph.cmd cd D:\Graphviz Пример 1. “Веса некоторых ребер совпадают”. Ввод:  Вывод: Консоль:    9  temp.dot:  Граф:    10   Пример 2.“Веса всех ребер одинаковые”. Ввод:   Вывод: Консоль:  temp.dot:    11   Граф:    12   Пример 3.“Веса всех ребер разные”. Ввод:  Вывод: Консоль:  temp.dot:    13  Граф:    14  Заключение РезультатомкурсовойработыявляетсяреализованныйалгоритмКрускала.Он        предназначендляпоискапостроенияминимальногоостовногодерева.       ПредставленныйалгоритмимеетсложностьO(MlogN),гдеM-количестворёберграфа,          аN-количествоеговершин.Входеданногоотчетамысмоглиубедиться,чтоданный               алгоритмдействительноявляетсядостаточноэффективнымдлядостиженийэтойцели​,         нежелианалогичные,такиекакалгоритмПримаиалгоритмДейкстры,обладающие          болеевысокойсложностьюприопределённыхусловиях.Помимопостроения        минимальногоостовногодерева,алгоритмКрускалатакжеиспользуетсядля        нахождениянекоторыхприближенийзадачиШтейнера.Важнозаметить,чтоостовных         деревьевможетбытьнесколько,нобудетпредставлентолькосамыйпервый          подходящий под условие решения задачи вариант. Разработаннаяпрограммаспособнасправитьсясосвоейзадачей.Вперспективе         возможныдоработкаиоптимизацияалгоритма,представленноговданнойкурсовой         работе.   15   Список использованных источников 1.(Кормен Ю.Б., Лейзерсон Ч.Э., Ривест Р.Л, Штайн К.Э., 2013 год) 2.(“Алгоритм Крускала”, 2020) 3.(”Минимальное остовное дерево. Алгоритм Крускала”, 2008) 4.(”Алгоритм Крускала”, 2019) 16  