Оглавление Цель работы ............................................................................................................................................... 3 Исходные данные ...................................................................................................................................... 3 Ход работы .................................................................................................................................................. 3 Имитационное моделирование процесса функционирования невосстанавливаемых систем. ................................................................................................................................................................... 3 1. Моделирование первого периода ................................................................................................... 3 2. Моделирование второго периода ................................................................................................... 5 3. Моделирование третьего периода .................................................................................................. 6 Выводы ........................................................................................................................................................ 8 Листинг программы ................................................................................................................................. 9    Цель работы Исследование интенсивности отказов и функции надежности для невосстанавливаемых систем путем имитационного моделирования процесса функционирования невосстанавливаемой системы для трех периодов жизни системы. Построение зависимости 𝜆(𝑡) оценки интенсивности отказов от времени и функции надежности 𝑅(𝑡).  Исходные данные  Моделирование осуществляется для 𝑁 = 35 000 систем, которые поделены на 𝑘 = 2 групп, причем вероятность попадания в первую группу 𝑝1 = 0.3 , а во вторую 𝑝2 = 0.7. Интенсивность отказа для первой системы 𝜆1 = 0.7 и для второй 𝜆2 = 1.3. Ход работы Имитационное моделирование процесса функционирования невосстанавливаемых систем.  При имитационном моделировании необходимо провести 𝑁 экспериментов. В каждом эксперименте моделируется процесс функционирования одного экземпляра системы. Для 𝑖-ой системы моделирование состоит в вычислении значения случайной величины 𝑇𝑖 – времени работы этой системы до момента отказа. Для каждого периода жизни системы случайная величина 𝑇𝑖 вычисляется по своему алгоритму.  1. Моделирование первого периода  Для 𝑖-ой системы первоначально надо определить, к какому подмножеству она относится. Для этого используется распределение 𝑝𝑖 . После того, как номер 𝑖 подмножества определен, необходимо сгенерировать значение 𝑇𝑖 , как случайной величины, распределенной  поэкспоненциальному закону с параметром 𝜆𝑖 , который определяется по номеру подмножества. Определение 𝑇𝑖 осуществляется по формуле:  Среднее время работы 𝑖-ой системы определяется по формуле:  Затем для каждого t до ?̅? с шагом ∆𝑡 = 0.01 происходит подсчет систем, которые работают. Теоретическое значение функции надежности:  Экспериментальное значение функции надежности:  где, 𝑛𝑡 − число систем, работающих в момент времени 𝑡, 𝑛 − общее число систем.   Теоретическое значение интенсивности отказа:  Экспериментальное значение интенсивности отказа:  где 𝑛𝑡 − число работоспособных систем в момент 𝑡, 𝑛𝑡+∆𝑡 − число систем, работающих в момент 𝑡 + ∆𝑡, где ∆𝑡 = 0.001. Графики:  Рисунок 1. Функция надежности для 1-го периода   Рисунок 2. Интенсивность отказа для 1-го периода  2. Моделирование второго периода Для 𝑖-ой системы первоначально надо определить, к какому подмножеству она относится. Для этого используется распределение 𝑝𝑖 . После того, как номер 𝑖 подмножества определен, необходимо сгенерировать значение 𝑇𝑖 , как случайной величины, распределенной по экспоненциальному закону с параметром 𝜆𝑖 , который определяется по номеру подмножества. Значение времени 𝑖-ой системы определяется как  Среднее время работы 𝑖-ой системы определяется по формуле:  Затем для каждого t до ?̅? с шагом ∆𝑡 = 0.01 происходит подсчет систем, которые работают. Теоретическое значение функции надежности:  Экспериментальное значение функции надежности:  где, 𝑛𝑡 − число систем, работающих в момент времени 𝑡, 𝑛 − общее число систем.  Теоретическое значение интенсивности отказа:  Экспериментальное значение интенсивности отказа:   где 𝑛𝑡 − число работоспособных систем в момент 𝑡, 𝑛𝑡+∆𝑡 − число систем, работающих в момент 𝑡 + ∆𝑡, где ∆𝑡 = 0.001.  Графики:  Рисунок 1.  Функция надежности для 2-го периода   Рисунок 2. Интенсивность отказа для 2-го периода   3. Моделирование третьего периода  Для 𝑖-ой системы первоначально надо определить, к какому подмножеству она относится. Для этого используется распределение 𝑝𝑖 . После того, как номер 𝑖 подмножества определен, необходимо сгенерировать значение 𝑇𝑖 , как случайной величины, распределенной по экспоненциальному закону с параметром 𝜆𝑖 , который определяется по номеру подмножества. Значение времени 𝑖-ой системы определяется как   Среднее время работы 𝑖-ой системы определяется по формуле:   Затем для каждого t до 𝑇 с шагом ∆𝑡 = 0.01 происходит подсчет систем, которые работают.  Теоретическое значение функции надежности:   Экспериментальное значение функции надежности:   где, 𝑛𝑡 − число систем, работающих в момент времени 𝑡, 𝑛 − общее число систем.   Теоретическое значение интенсивности отказа:  Экспериментальное значение интенсивности отказа:   где 𝑛𝑡 − число работоспособных систем в момент 𝑡, 𝑛𝑡+∆𝑡 − число систем, работающих в момент 𝑡 + ∆𝑡, где ∆𝑡 = 0.001 Графики:  Рисунок 3.  Функция надежности для 3-го периода   Рисунок 4. Интенсивность отказа для 3-го периода  Выводы В ходе выполнения лабораторной работы были смоделированы работы трех периодов невосстанавливаемых систем, а также, были получены экспериментальные значения функции надежности 𝑅(𝑡) и интенсивности отказа 𝜆(𝑡).  Экспериментальные значения функции надежности 𝑅(𝑡) и интенсивности отказа 𝜆(𝑡) близки по значениям с теоретическими значениями, что свидетельствует о корректной работе программы.   Листинг программы import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList;  public class Modeling {     private int n = 35000;     private double l1 = 0.7;     private double l2 = 1.3;     private double p1 = 0.3;     private double p2 = 0.7;          private double T;     private ArrayList Ti = new ArrayList();      private void timeModeling1() {         for (int i = 0; i < n; i++) {             double tmp = Math.random();             if (((double) i / n - (p1 + p2) < 0.01)) {                 Ti.add((Math.log(tmp) / l1) * (-1));                 continue;             }             if ((((double) i / n - (p1 + p2)) >= 0.01) & (((double) i / n - (p1 + p2)) < 0.02)) {                 Ti.add((Math.log(tmp) / l2) * (-1));                 continue;             } else {                 Ti.add((Math.log(tmp) / l3) * (-1));                 //System.out.println("r");             }         }     }      private void timeModeling2() {         for (int i = 0; i < n; i++) {             double tmp1 = (-1) * Math.log(Math.random());             double tmp2 = (-1) * Math.log(Math.random());             if (tmp1 / l1 <= tmp2 / l2)                 Ti.add(tmp1 / l1);             else                 Ti.add(tmp2 / l2);         }     }      private void timeModeling3() {         for (int i = 0; i < n; i++) {             double tmp1 = (-1) * Math.log(Math.random());             double tmp2 = (-1) * Math.log(Math.random());             if (tmp1 / l1 >= tmp2 / l2)                 Ti.add(tmp1 / l1);             else                 Ti.add(tmp2 / l2);         }     }      public void AverageT() {         for (int i = 0; i < Ti.size(); i++) {             T += (double) Ti.get(i);         }         T /= n;     }      public void Theoretical1() {         for (double t = 0; t - T <= 0.0; t += 0.01) {             double R = 0;             double l = 0;             R = Math.exp(-l1 * t) * p1 + Math.exp(-l2 * t) * p2 + Math.exp(-l3 * t) * p3;             l = (l1 * p1 * Math.exp((-1) * l1 * t) + l2 * p2 * Math.exp((-1) * l2 * t) + l3 * p3 * Math.exp((-1) * l3 * t)) / R;             writeStringToFile(R, t, "TheorR(t)1.txt");             writeStringToFile(l, t, "TheorL(t)1.txt");         }     }      public void Theoretical2() {         double l = l1 + l2;         for (double t = 0; t - T <= 0.0; t += 0.01) {             double R = 0;             R = Math.exp(-l1 * t) * Math.exp(-l2 * t);             writeStringToFile(R, t, "TheorR(t)2.txt");             writeStringToFile(l, t, "TheorL(t)2.txt");         }     }      public void Theoretical3() {         for (double t = 0; t - T <= 0.0; t += 0.01) {             double R = 0;             double l = 0;             R = Math.exp(-l1 * t) + Math.exp(-l2 * t) - Math.exp(-l1 * t) * Math.exp(-l2 * t);             writeStringToFile(R, t, "TheorR(t)3.txt");             l = (-1) * ((-1) * l1 * Math.exp((-1) * l1 * t) - l2 * Math.exp((-1) * l2 * t) + (l1 + l2) * Math.exp((-                     1) * (l1 + l2) * t)) / R;             writeStringToFile(l, t, "TheorL(t)3.txt");         }     }      public int findN(double t) {         int nT = 0;         for (int i = 0; i < Ti.size(); i++) {             if (t <= (double) Ti.get(i)) {                 nT++;             }         }         return nT;     }      public void Experimental(String filename1, String filename2) {         for (double t = 0; t < T; t += 0.01) {             int nT = findN(t);             double R = (double) nT / n;             writeStringToFile(R, t, filename1);             double l = (double) (nT - findN(t + 0.001)) / (nT * 0.001);             writeStringToFile(l, t, filename2);         }     }      public void writeStringToFile(double R, double t, String filename) {         try {             FileWriter file = new FileWriter(filename, true);             StringBuilder str = new StringBuilder();             str.append(t).append(" ").append(R).append("\n");             file.write(str.toString());             file.flush();         } catch (IOException ex) {             System.out.println(ex.getMessage());             ex.printStackTrace();         }     }      public void firstModeling() {         Ti.clear();         T = 0;         timeModeling1();         AverageT();         Experimental("ExpR(t)1.txt", "ExpL(t)1.txt");         Theoretical1();     }      public void secondModeling() {         Ti.clear();         T = 0;         timeModeling2();         AverageT();         Experimental("ExpR(t)2.txt", "ExpL(t)2.txt");         Theoretical2();     }      public void thirdModeling() {         Ti.clear();         T = 0;         timeModeling3();         AverageT();         Experimental("ExpR(t)3.txt", "ExpL(t)3.txt");         Theoretical3();     }      public static void main(String[] args) {         Modeling m = new Modeling();         m.firstModeling();         m.secondModeling();         m.thirdModeling();     } }  