1.Цель работыНаписать программу, реализующую работу с барьерами2.Ход работыОсновнойпотоксоздаетобъекттипа«барьер»припомощифункцииbarrier_init0иинициализируетегозначениемсчетчика,равнымчислупотоков(включаясебя),которыедолжны«встретиться»убарьера,преждечемон«прорвется».Вданнойработеиндексравен3—одиндляпотокаmain(),одиндляпотокаthread1()иодиндляпотокаthread2().Далеепотокистартуют.Дляосуществлениясинхронизацииосновнойпоток(mаin())блокируетсамсебянабарьере,таккакбарьербудетразблокировантолькопослетого,какрабочиепотокианалогичноприсоединятсякнему.Послетогокакнужноечислопотоковвыполнитвызовфункцииbarrier_wait(),всеэтипотокибудутразблокированы«одновременно».3.Листинг программы#include <stdio.h>#include <time.h>#include <sync.h>#include <sys/neutrino.h>barrier_t barrier;//int data_ready = 0;//int inf = 0;//pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//pthread_cond_t condvar = PTHREAD_COND_INITIALIZER;void *thread1 (void *not_used){time_t now;char buf[27];time(&now);2printf("Potok 1, vremia starta %s \n", ctime_r(&now,buf));sleep(3);barrier_wait(&barrier);time(&now);printf("barier v potoke 1, vremia srabativania %s\n", ctime_r(&now,buf));}void *thread2 (void * not_used){time_t now;char buf[27];time(&now);printf("Potok 2, vremia starta %s \n", ctime_r(&now,buf));sleep(6);barrier_wait(&barrier);time(&now);printf("barier v potoke 2, vremia srabativania %s\n", ctime_r(&now,buf));}main(){time_t now;char buf[27];barrier_init(&barrier, NULL, 3);printf("Start \n");pthread_create(NULL,NULL, thread1 ,NULL);pthread_create(NULL,NULL, thread2 ,NULL);time(&now);printf("Main(): oshidanie y bariera, vremia %s\n",ctime_r(&now,buf));barrier_wait(&barrier);time(&now);printf("barier v main(), vremia srabativania %s\n",ctime_r(&now,buf));sleep(5);}34.Результат работы программыРисунок 1 - Результаты работы программы5.Временная диаграммаРисунок 2 - Временная диаграмма46.ВыводВходевыполнениялабораторнойработыбылареализованапрограммадляосвоениянавыковработысбарьерамиприпомощифункцииbarrier_wait().5