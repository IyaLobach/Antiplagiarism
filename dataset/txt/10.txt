1. Цель работы: Целью нашей работы является ознакомление с алгоритмами однонаправленных хеш-функций. В данном случае рассматривается семейство алгоритмов SHA-2(реализован алгоритм SHA-256). Так же лабораторная работа подразумевает проведение эксперимента на нахождение второго прообраза и коллизий на малом количестве бит (8, 10, 12, 14, 16).  2. Описание алгоритма: Хеш-функции семейства SHA-2 построены на основе структуры Меркла — Дамгора. Исходное сообщение после дополнения разбивается на блоки, каждый блок — на 16 слов. Алгоритм пропускает каждый блок сообщения через цикл с 64 или 80 итерациями (раундами). На каждой итерации 2 слова преобразуются, функцию преобразования задают остальные слова. Результаты обработки каждого блока складываются, сумма является значением хеш-функции. Тем не менее, инициализация внутреннего состояния производится результатом обработки предыдущего блока. Поэтому независимо обрабатывать блоки и складывать результаты нельзя.    Рис.1 – Схема одной итерации алгоритмов семейства SHA-2            3. Реализация алгоритма: 3.1. Сначала инициализируются определённые константы.  1) Первые 32 бита дробных частей квадратных корней первых восьми простых чисел [от 2 до 19]:   Рис.2 – Первые восемь простых чисел  2) Первые 32 бита дробных частей кубических корней первых 64 простых чисел [от 2 до 311]:   Рис.3 – Дробные части кубических корней простых чисел   3.2.  К сообщению, хэш которого нам надо получить, добавляется 1, потом K нулевых бит так, чтобы (L + 1 + K) mod 512 = 448, где L — число бит в сообщении. Последние 8 байт отводятся на 64-битное число, которое означает длину исходного сообщения.           3.3. Далее сообщение обрабатывается кусками по 512 бит определённым образом:  Рис.4 – обработка кусков сообщения  3.4. После обработки, вычисленные значение добавляются к ранее вычисленным результатам:   Рис.5 – суммирование с прошлыми результатами  3.5. После всех преобразований, результаты работы программы, которые находятся в переменных от h0 до h7 конкатенируются. Это итоговое значение и является хэшем изначального сообщения.   4. Примеры работы программы:  Пример 1:  Рис.6 – Хэш сообщения из проверенного источника   Рис.7 – Хэш сообщения из реализованной программы  Пример 2:  Рис.8 – Хэш сообщения из проверенного источника   Рис.9 – Хэш сообщения из реализованной программы  Как видно из результатов, хэши совпадают, следовательно, программа реализована верно.  5. Результаты экспериментов: Количество N для нахождения второго прообраза (1000 экспериментов):         Таблица 1 – количество попыток нахождения прообраза Слово - пароль 8 бит 10 бит 12 бит 14 бит 16 бит sha-256 28 984 4062 16516 16777 inskip1 425 1055 4488 16777 16777 0000000 28 1026 4254 16193 16777   Рис.10 – График нахождения прообразов для 3 паролей Синий – первый пароль Красный – второй пароль Зелёный – третий пароль      Таблица 2 – количество попыток нахождения коллизии Слово - пароль 8 бит 10 бит 12 бит 14 бит 16 бит sha-256 22 32 66 34 322 inskip1 23 34 61 34 333 0000000 22 34 67 35 325   Рис.11 - График нахождения коллизий для 3 паролей Синий – первый пароль Красный – второй пароль Зелёный – третий пароль  Исходя из результатов экспериментов, можно сделать вывод, что чем больше бит в хэше, тем труднее найти прообразы и коллизии.   6. Вывод:  Алгоритмы SHA-2 актуальны и сейчас, они используются в сертификате SSL при установлении защищённого соединения на сайтах. Также семейство активно используется в майнинге криптовалют. Особых уязвимостей семейства обнаружено не было (кроме усеченных версий). Тем не менее в 2012 году NIST принял в качестве стандарта SHA-3.  7. Литература: 1) А.Л. Чмора "Современная прикладная криптография" 2) Б.Я. Рябко "Основы современной криптографии для специалистов в ИТ" 3) Баричев, Серов “Основы современной криптографии” 