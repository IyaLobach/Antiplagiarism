2 1. Ğ¦ĞµĞ»ÑŒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ˜ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ»Ñ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼Ñ‹Ñ… ÑĞ¸ÑÑ‚ĞµĞ¼ Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑÑ‚Ğ¸ Ğ¸Ğ¼Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾Ğµ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ ÑĞ¾ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¹ ÑÑ…ĞµĞ¼Ğ¾Ğ¹ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ 2. Ğ¥Ğ¾Ğ´ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ñƒ 1:  ğœ†=1.2 - ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚ Ğ¸Ğ½Ñ‚ĞµĞ½ÑĞ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ĞºĞ°Ğ·Ğ¾Ğ² ğœ‡=1.1 - ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚ Ğ¸Ğ½Ñ‚ĞµĞ½ÑĞ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ ğ¾Ğ“+=1âˆ’(1âˆ’ğ¾Ğ“1,1)3= 1âˆ’ï¿½1âˆ’ğœ‡ğœ‡+ğœ†ï¿½3=0.857976 - Ğ²ĞµÑ€Ñ…Ğ½ÑÑ Ğ¾Ñ†ĞµĞ½ĞºĞ° ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸; ğ¾Ğ“1âˆ’=ğ¾Ğ“1,1+ğ¾Ğ“2,1âˆ’ ğ¾Ğ“1,1âˆ™ ğ¾Ğ“2,1=ğœ‡ğœ‡+ğœ†+ 2ğœ‡ğœ†+ğœ‡22ğœ†+2ğœ‡ğœ†+ğœ‡2âˆ’ ğœ‡ğœ‡+ğœ†âˆ— 2ğœ‡ğœ†+ğœ‡22ğœ†+2ğœ‡ğœ†+ğœ‡2=   =0.776729 - Ğ½Ğ¸Ğ¶Ğ½ÑÑ Ğ¾Ñ†ĞµĞ½ĞºĞ° ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ¾Ğ¼ (Ñ€Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ±Ñ€Ğ¸Ğ³Ğ°Ğ´Ñ‹); ğ¾Ğ“2âˆ’=1âˆ’(1âˆ’ğ¾Ğ“1,1)2=1âˆ’ï¿½1âˆ’ğœ‡ğœ‡+ğœ†ï¿½2=0.727788 - Ğ½Ğ¸Ğ¶Ğ½ÑÑ Ğ¾Ñ†ĞµĞ½ĞºĞ° ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ²Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ¾Ğ¼ (Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹). 3  Ğ Ğ¸ÑÑƒĞ½Ğ¾Ğº 1 - Ğ³Ñ€Ğ°Ñ„Ğ¸Ğº Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ 3. Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ’ Ñ…Ğ¾Ğ´Ğµ Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ¹ Ğ»Ğ°Ğ±Ğ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½ Ğ³Ñ€Ğ°Ñ„Ğ¸Ğº Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ¸ ĞµĞ³Ğ¾ Ğ²ĞµÑ€Ñ…Ğ½ÑÑ Ğ¸ Ğ½Ğ¸Ğ¶Ğ½Ğ¸Ğµ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹. ĞŸĞ¾ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°Ğ¼ Ğ²Ğ¸Ğ´Ğ½Ğ¾, Ñ‡Ñ‚Ğ¾ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸, Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ñ‹Ğ¹ ÑĞ¼Ğ¿Ğ¸Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ğ¿ÑƒÑ‚ĞµĞ¼, Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ½Ğ¸Ğ¶Ğ½ĞµĞ¹ Ğ¸ Ğ²ĞµÑ€Ñ…Ğ½ĞµĞ¹ Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ°Ğ¼Ğ¸ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸. Ğ˜ÑÑ…Ğ¾Ğ´Ñ Ğ¸Ğ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑƒĞ±ĞµĞ´Ğ¸Ñ‚ÑŒÑÑ, Ñ‡Ñ‚Ğ¾ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ²ĞµÑ€Ğ½Ğ¾.             4 ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ Ğ›Ğ¸ÑÑ‚Ğ¸Ğ½Ğ³ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹ import java.io.IOException; import java.util.ArrayList;  public class Second {     private ArrayList<Integer> model3on2(ArrayList<Double> t, double lambda, double myu) {         ArrayList<Integer> res = new ArrayList<>();         int numberOfBlocks = 3;         int numOfWorkers = 2;         int freeWorkers = numOfWorkers;          ArrayList<Boolean> workingBlocks = new ArrayList<>();         ArrayList<Boolean> repairingNow = new ArrayList<>();         ArrayList<Integer> queue = new ArrayList<>();          for (int i = 0; i < numberOfBlocks; i++) {             workingBlocks.add(true);             repairingNow.add(false);         }          ArrayList<Double> T = new ArrayList<>();         for (int i = 0; i < numberOfBlocks; i++) {             T.add(-Math.log(Math.random()) / lambda);         }          for (int step = 0; step < t.size(); step++) {             ArrayList<Integer> removeFromQueue = new ArrayList<>();             for (int i = 0; i < T.size(); i++) {                 if (T.get(i) < t.get(step)) {                     workingBlocks.set(i, false);                     if (!queue.contains(i)) {                         if (!repairingNow.get(i)) {                             queue.add(i);                         }                         else {                             freeWorkers += 1;                             double tmp = -Math.log(Math.random()) / lambda;                             T.set(i, T.get(i) + tmp);                             repairingNow.set(i, false);                             workingBlocks.set(i, true);                         }                     }                     if (queue.contains(i)) {                         if (queue.indexOf(i) < freeWorkers) {                             double tmp = -Math.log(Math.random()) / myu;                             T.set(i, T.get(i) + tmp);                             repairingNow.set(i, true);                             removeFromQueue.add(i);                         }                     }                 }             }              freeWorkers -= removeFromQueue.size();             for (int r : removeFromQueue) {                 queue.remove((Integer) r);             }             if (workingBlocks.get(0) || workingBlocks.get(1) || 5 workingBlocks.get(2)) {                 res.add(1);             }             else {                 res.add(0);             }         }         return res;     }      public Second(double lambda, double myu) throws IOException {         int N = 50000;         double dt = 0.01;         ArrayList<Double> t = fillP(10, dt);          double min1 = (1 - pow2(1 - (myu / (myu + lambda))));         System.out.println(min1);          double min2 = (myu / (myu + lambda)) +                 (2 * myu * lambda + pow2(myu)) / (2 * pow2(lambda) + 2 * myu * lambda + pow2(myu)) -                 (myu / (myu + lambda)) * (2 * myu * lambda + pow2(myu)) / (2 * pow2(lambda) + 2 * myu * lambda + pow2(myu));         System.out.println(min2);          double max = (1 - Math.pow(1 - (myu / (myu + lambda)), 3));         System.out.println(max);           ArrayList<Double> experiment = fillNulls(t.size());         ArrayList<Integer> exp;         for (int n = 0; n < N; n++) {             exp = model3on2(t, lambda, myu);             for (int i = 0; i < experiment.size(); i++) {                 experiment.set(i, experiment.get(i) + exp.get(i));             }         }          for (int i = 0; i < experiment.size(); i++) {             experiment.set(i, experiment.get(i) / N);         }         Files files = new Files();         files.graphFiles(2, experiment, dt);         files.graphFileForNum(1, experiment.size(), max, dt);         files.graphFileForNum(2, experiment.size(), min1, dt);         files.graphFileForNum(3, experiment.size(), min2, dt);     }      public static double pow2(double num) {         return Math.pow(num, 2);     }      private ArrayList<Double> fillNulls(int num) {         ArrayList<Double> res = new ArrayList<>();         for (int i = 0; i < num; i++) {             res.add(0.0);         }         return res;     }      private ArrayList<Integer> fillNullsInt(int num) {         ArrayList<Integer> res = new ArrayList<>();         for (int i = 0; i < num; i++) {             res.add(0); 6         }         return res;     }      private ArrayList<Double> fillP(int end, double dt) {         ArrayList<Double> res = new ArrayList<>();         int size = (int) (end / dt);         for (int i = 0; i < size; i++) {             res.add(dt * i);         }         return res;     } }  